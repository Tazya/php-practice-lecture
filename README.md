# Веб-сервис на PHP

### Веб в PHP
В отличие от других языков программирования, PHP содержит множество встроенных особенностей для работы с Веб-страницами.
Эти особенности связаны с его историческим развитием и ролью главного языка для создания веб-сайтов на протяжении многих лет.

Одна из главных фич - PHP сам по сути является шаблонизатором и выводит на страницу всё, что не заключено в теги `<?php ?>`. Кроме того, у PHP на борту есть встроенный веб-сервер, который можно использовать только для локальной разработки.  
Поэтому, для создания сайта нам достаточно написать HTML-разметку и поместить код в php-теги.
```php
<!DOCTYPE html>
<html>
    <body>
        <h1><?php echo 'Hello'; ?></h1>
    </body>
</html>
```
и запустить сервер `php -S localhost:8000`.

На первый взгляд всё хорошо, но при расширении функционала страницы, она очень быстро прирастает кодом, PHP смешивается с HTML и превращается в кашу:
```php
<?php
    include_once 'advert.php';

    $title = htmlentities($_POST['title']);
    $description = htmlentities($_POST['description']);

    if (empty($title)){
        echo "<p class=\"validation-error\">Заголовок не может быть пустым</p>";
    } elseif (empty($description) {
        echo "<p class=\"validation-error\">Описание не может быть пустым</p>";
    } else {
        $data = [
            'title' => $title,
            'description' => $description,
        ];

        $advert = new Advert($data);
        $advert->save();

        echo "<p>Объявление создано: " . $title . "</p>";
    }
?>

<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Создание объявления</title>
    <style>
      .validation-error{color:red;}
      input{display:block; margin-bottom:10px;}
      h1{font-size:28px;}
      form{padding: 20px 10px;}
    </style>
  </head>

  <body>
    <h1>Новое объявление</h1>

    <form action="submit.php" method="post">
      <label for="">Заголовок:</label>
      <input name="title" id="title" type="text" value="<?php echo($title); ?>" />

      <label for="description">Описание:</label>
      <input name="description" id="description" type="textarea" value="<?php echo($description); ?>" />

      <input type="submit" value="Submit" />
    </form>
  </body>
</html>
```

Шаблон, стили и исполняемый код в одном файле. Если представить, что нужно добавить новые поля, их обработку, добавить защиту от XSS-атак, то можно создать огромный файл с очень запутанным кодом, который впоследствии будет невозможно поддерживать.
Любой развивающийся сайт или сервис, содержит десятки и сотни тысяч строк кода, нуждающихся в поддержке и обновлении. Поэтому код из примера нужен только для того, чтобы знать, как не стоит делать.

Чтобы сервис было возможно развивать, в ходе лекции, мы познакомимся с популярным архитектурным подходом, называемым MVC. MVC - это шаблон проектирования, предназначенный для удобной работы c HTTP.
Шаблон проектирования - это повторяемая конструкция, которая решает часто возникающие проблемы. В любом случае это не догма и не спецификация и всегда оставляет вам место для самостоятельного выбора.

```mermaid
flowchart LR
    Model-->Controller
    Controller-->View
    View-->Controller
    Controller-->Model
```
Расшифровка **MVC**:
- **M - Model** - Слой логического ядра приложения, оно не должно влиять и зависеть от других частей приложения.
- **С - Controller**  - обработчик, который взаимодействует с Model для обработки входящих запросов и отдаёт информацию в View.
- **V - View** - Слой, отвечающий за отображение данных. Он получает данные от Controller. Наиболее часто используется для отрисовки веб-страниц.

Какая бы ни была архитектура вашего приложения - основная идея в том, чтобы разделить его на слои абстракции, каждый из которых будет изолированно выполнять свою роль.

Перед тем, как приступить к практической разработке сервиса, вспомним как программы обмениваются данными по сети и выделим общие признаки для всех веб-сервисов.

### Жизненный цикл
HTTP - основной протокол, используемый в веб для передачи и получения данных. Данными в этом случае обмениваются два участника - Клиент и Сервер.
```mermaid
  sequenceDiagram;
      participant Клиент
      participant Сервер
      Клиент-->>Сервер: HTTP GET /
      Сервер-->>Клиент: text/html
      Клиент-->>Сервер: HTTP GET /cabinet
      Сервер-->>Клиент: text/html
```

1. Клиент (браузер, постман, curl и т.д.) делает HTTP-запрос на адрес нашего сервиса.  
   Запрос может быть в корень сайта localhost:8000 или запрос localhost:8000/health или localhost:8000/cabinet.   
   То, что расположено после хоста, обычно называют путь (относительный uri, эндпоинт, роут) Как правило, слова, из которых состоит путь, должны быть понятны человеком и связаны с сущностью, к которой мы обращаемся по этому роуту.
2. Сервер возвращает ответ в виде строки (json, html, простой текст) с успешным статусом или ошибкой.
Эти действия не зависят от кода, и клиент не знает на каком языке написана логика, вернувшая ответ.

Что происходит внутри сервера:
```mermaid
flowchart LR
    Client-->localhost:8000
    Client-->localhost:8000/cabinet
    localhost:8000-->index.php
    localhost:8000/cabinet-->index.php

    subgraph PHP
    index.php
    end
```
Внутри сервера работает программа, которая:
1. Принимает запрос.
2. Определяет какое действие нужно выполнить (Маршрутизация).
3. Выполняет обработку.
4. Возвращает ответ в формате, в котором клиент готов его воспринять.

Эти 4 шага можно взять за основу нашей архитектуры, так как они будут выполняться в любом случае, независимо от логики приложения.
Cхема будет расширяться и усложняться по мере прохождения практики.

## Создание сервиса на PHP.
Начнём создание нового проекта с чистого листа, и для начала создадим директорию и инициализируем новый пакет через composer:

```bash
mkdir my-php-project
cd my-php-project
composer init
```

Создадим файл index.php в директории public
```bash
mkdir public
touch public/index.php
```

Открываем любимый редактор и пишем зачаток нашего сервиса, выведем на экран содержимое глобальной переменной `$_SERVER`:
```php
<?php

echo '<pre>';
print_r($_SERVER);
```

Убедимся в том, что наш скрипт работает и запустим встроенный PHP-сервер в директории `public`.
```bash
php -S localhost:8000
```
Если перейти по адресу http://localhost:8000/, то можно увидеть вывод ассоциативного массива с данными сервера.
Сейчас нас интересует значение REQUEST_URI, и REQUEST_METHOD, показывающие, по какому пути и методу HTTP хочет обратиться клиент.

К примеру, если сделать запрос http://localhost:8000/hello, то REQUEST_URI будет содержать строку `/hello`
На основе этих значений и можно выбирать логику обработки запроса (Выполнить маршрутизацию)

Давайте попробуем сделать это и напишем простую реализацию роутера.

```php
<?php

$uri = $_SERVER['REQUEST_URI'];

if ($uri === '/hello') {
    $name = $_GET['name'] ?? 'guest';

    echo 'Hello ' . $name;
} elseif ($uri === '/server') {
    header('Content-Type: application/json; charset=utf-8');
    json_encode($_SERVER, JSON_PRETTY_PRINT|JSON_UNESCAPED_UNICODE);
} else {
    header("HTTP/1.1 404 Not Found");

    echo '404 Not Found';
}
```
Попробуем перейти по адресам и проверить вывод:
http://localhost:8000/hello
http://localhost:8000/server
http://localhost:8000/blabla

Теперь воспользуемся написанным нами функционалом по выводу имени и перейдём в http://localhost:8000/hello?name=Stark
И тут неожиданно выводится 404? Почему?
REQUEST_URI - содержит теперь так-же query-параметры, `/hello?name=Stark` и уже не подходят ни по одному условию.
Решить проблему можно с помощью функции `parse_url()`, которая разобъёт нашкт строку на 2 части - `path` и `query`.

И это только одна из проблем, с которыми мы столкнёмся. Например:
- Что если мы забудем прописать нужный заголовок, или допустим в нём ошибку?
- Что делать, если пользователь введёт путь так, с закрывающим слешем?: http://localhost:8000/hello/
- Как декодировать и кодировать html-символы
- Как защищаться от XSS-атак.

Это всё можно будет решить "в лоб", но код очень быстро вырастет и превратится в настоящую кашу, учитывая, что логика будет расширяться и проект расти.

### Разбиение на слои абстракции
Наденем мантию архитектора и подумаем, что из кода выше можно выделить и абстрагировать, чтобы можно было писать бизнес-логику и не отвлекаться на проблемы с запросами, ответами, заголовками и прочим, связанным с HTTP.

- **Запрос (Request)** - Содержит в себе заголовки, тело и мета-данные запроса.
- **Ответ (Response)** - Содержит заголовки и тело ответа.
- **Router** - Позволяет определить какой код нужно выполнить на основании Запроса.
- **Controller** - Класс, методы которого будут запущены роутером. Получает Запрос, формирует и возвращает Ответ.

Обновим нашу схему:

```mermaid
flowchart LR
    Client-->/
    Client-->/cabinet
    /-->index.php
    /cabinet-->index.php

    subgraph PHP
    index.php-->Request-->Router
    Router-->IndexController-->Response
    Router-->CabinetController-->Response
    end
```
 
Эти абстракции оказались настолько удобны, что распространились повсеместно, и на их основе были написаны фреймворки и микрофреймоврки.
По-сути, они являются набором инструментов для решения задач, которые часто встречаются в веб-разработке.

**Фреймворки** - предоставляют готовую базовую архитектуру и множество встроенных возможностей, в мире PHP ориентированы на создание сайтов.  
**Микрофреймворки** - предоставляют набор базовых инструментов для создания веб-приложений, маршрутизация - один из них. Но не обязывает следовать определенной архитектуре.

Все фреймворки решают примерно одинаковый круг задач. Что именно выбрать и использвать ли их вообще - зависит от ситуации и опыта программиста.

### Подключим микрофреймворк к веб-сервису и воспользуемся его роутером.
Как пример, можно воспользоваться роутером, который идет в комплекте с микрофреймворком lumen.
Установим микрофреймворк Lumen в зависимости нашего проекта.
```bash
composer require laravel/lumen
```

Подключим автозагрузку и запустим приложение.
```php
// public/index.php
<?php

// Загружеаем автолоадер
require_once __DIR__ . '/../vendor/autoload.php';

// Подключаем неймспейс
use Laravel\Lumen\Application;

// Создаём и возвращаем объект нашего приложения
$app = new Application(dirname(__DIR__));

$app->run();
```

Теперь можно снова открыть в браузере http://localhost:8000 и убедиться, что приложение запущено.

Воспользуемся роутером и сделаем обработчики для тех страниц, что мы сделали ранее.
```php
<?php

require_once __DIR__ . '/../vendor/autoload.php';

use Illuminate\Http\Request;
use Laravel\Lumen\Application;

$app = new Application(dirname(__DIR__));

$app->router->get('/', function () {
    return 'Hello Kolesa Backend Upgrade!';
});

$app->router->get('/hello', function (Request $request) {
    $name = $request->input('name', 'guest');

    return 'Hello ' . $name;
});

$app->router->get('/server', function () {
    // Пример протечки абстракции - прямое обращение к глобальной переменной
    return response()->json($_SERVER);
});

$app->run();
```
Теперь у нас появилось взаимодействие с новыми объектами, и мы больше не управляем напрямую заголовками и выводом, а используем методы, которые позволяют получить данные из запроса и записать их в ответ.
